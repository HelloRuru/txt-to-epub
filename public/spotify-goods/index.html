<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

  <!-- SEO -->
  <title>Spotify Goods — 歌曲整理小幫手 | HelloRuru Tools</title>
  <meta name="description" content="貼上 YouTube 或 YouTube Music 網址自動抓歌，也可手動輸入歌名。一鍵建立 Spotify 歌單或匯入現有歌單，支援封面上傳。完全免費、不需註冊，全程在瀏覽器完成。">
  <meta name="keywords" content="YouTube Music,YouTube,Spotify,歌單轉換,播放清單,playlist transfer,音樂搬家,免費工具,歌單匯入,封面上傳">
  <link rel="canonical" href="https://tools.helloruru.com/spotify-goods/">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Spotify Goods — 歌曲整理小幫手 | HelloRuru Tools">
  <meta property="og:description" content="貼上 YouTube 或 YouTube Music 網址自動抓歌，也可手動輸入歌名。一鍵建立或匯入 Spotify 歌單，支援封面上傳。完全免費，全程瀏覽器處理。">
  <meta property="og:url" content="https://tools.helloruru.com/spotify-goods/">
  <meta property="og:site_name" content="Hello Ruru Tools">
  <meta property="og:locale" content="zh_TW">

  <!-- Open Graph Image -->
  <meta property="og:image" content="https://tools.helloruru.com/spotify-goods/og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="Spotify Goods — 歌曲整理小幫手">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Spotify Goods — 歌曲整理小幫手 | HelloRuru Tools">
  <meta name="twitter:description" content="貼上 YouTube 或 YouTube Music 網址自動抓歌，也可手動輸入歌名。一鍵建立或匯入 Spotify 歌單，支援封面上傳。完全免費，全程瀏覽器處理。">
  <meta name="twitter:image" content="https://tools.helloruru.com/spotify-goods/og-image.png">

  <!-- Favicon -->
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">

  <!-- Brand Header -->
  <script src="https://lab.helloruru.com/shared/brand-header.js"></script>

  <!-- JSON-LD -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Spotify Goods — 歌曲整理小幫手",
    "applicationCategory": "UtilitiesApplication",
    "url": "https://tools.helloruru.com/spotify-goods/",
    "description": "貼上 YouTube 或 YouTube Music 網址自動抓歌，也可手動輸入歌名。一鍵建立或匯入 Spotify 歌單，支援封面上傳。完全免費，全程瀏覽器處理。",
    "featureList": [
      "貼上 YouTube / YouTube Music 網址自動抓歌",
      "支援影片、歌單、頻道整批匯入",
      "手動輸入歌名清單",
      "建立新歌單或匯入現有歌單",
      "支援歌單封面上傳",
      "搜尋過程可隨時取消",
      "完全免費、不需註冊",
      "全程瀏覽器處理，不上傳任何資料"
    ],
    "offers": { "@type": "Offer", "price": "0", "priceCurrency": "TWD" },
    "creator": { "@type": "Organization", "name": "Hello Ruru", "url": "https://ohruru.com" }
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      { "@type": "Question", "name": "Spotify Goods 是免費的嗎？", "acceptedAnswer": { "@type": "Answer", "text": "完全免費，不用註冊，也沒有廣告。" }},
      { "@type": "Question", "name": "我的資料安全嗎？", "acceptedAnswer": { "@type": "Answer", "text": "所有操作都在你的瀏覽器完成，登入資訊不會上傳到任何伺服器。" }},
      { "@type": "Question", "name": "支援哪些網址？", "acceptedAnswer": { "@type": "Answer", "text": "YouTube 影片、YouTube Music 歌單、頻道頁面都可以，也能直接手動輸入歌名。" }},
      { "@type": "Question", "name": "可以加進現有的 Spotify 歌單嗎？", "acceptedAnswer": { "@type": "Answer", "text": "可以，搜尋完成後選擇「加進現有歌單」，從你的歌單清單中挑選即可。" }},
      { "@type": "Question", "name": "為什麼有些歌在 Spotify 找不到？", "acceptedAnswer": { "@type": "Answer", "text": "可能是 Spotify 沒有上架，或歌名與 Spotify 上的版本不同。你可以手動修改歌名再搜尋。" }},
      { "@type": "Question", "name": "YouTube 播放電台能用嗎？", "acceptedAnswer": { "@type": "Answer", "text": "電台是 YouTube 隨機推薦的，每個人不同，無法透過網址抓取。建議改貼一般歌單連結。" }}
    ]
  }
  </script>

  <style>
    @font-face { font-family: 'GenSenRounded'; src: url('https://lab.helloruru.com/fonts/GenSenRounded-Regular.woff2') format('woff2'); font-weight: 400; font-style: normal; font-display: swap; }
    @font-face { font-family: 'GenSenRounded'; src: url('https://lab.helloruru.com/fonts/GenSenRounded-Bold.woff2') format('woff2'); font-weight: 700; font-style: normal; font-display: swap; }

    :root {
      --c-rose: #D4A5A5;
      --c-lavender: #B8A9C9;
      --c-ink: #3D3535;
      --c-bg: #FFFCFA;
      --c-card: #FFFFFF;
      --c-border: rgba(212,165,165,0.15);
      --c-success: #1DB954;
      --c-error: #C07070;
      --c-muted: #A09090;
      --radius: 24px;
      --radius-sm: 12px;
      --shadow: 0 4px 24px rgba(212,165,165,0.12);
    }

    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'GenSenRounded', 'Noto Sans TC', sans-serif; background: var(--c-bg); color: var(--c-ink); line-height: 1.7; -webkit-font-smoothing: antialiased; }
    a { color: var(--c-lavender); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .hidden { display: none !important; }

    /* Container */
    .container { max-width: 960px; margin: 0 auto; padding: 0 20px 40px; }

    /* Hero */
    .hero { text-align: center; padding: 32px 20px 14px; }
    .hero-icons { display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 10px; }
    .hero-icon-box {
      width: 48px; height: 48px; border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
    }
    .hero-icon-box.ytm { background: rgba(255,0,0,0.06); }
    .hero-icon-box.sp { background: rgba(29,185,84,0.06); }
    .hero-arrow { color: var(--c-muted); opacity: 0.5; }
    .hero h1 {
      font-size: 2rem; font-weight: 700;
      background: linear-gradient(135deg, var(--c-rose) 0%, var(--c-lavender) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .hero-sub { color: #6B5B5B; font-size: 0.92rem; margin-top: 2px; }
    .hero-badges { display: flex; gap: 6px; justify-content: center; margin-top: 10px; flex-wrap: wrap; }
    .badge { font-size: 0.7rem; padding: 3px 10px; border-radius: 20px; background: rgba(184,169,201,0.1); color: #8B7BA0; }

    /* User bar (shown after login, replaces Step 1) */
    .user-bar {
      display: flex; align-items: center; gap: 10px;
      padding: 10px 16px; border-radius: var(--radius-sm);
      background: var(--c-card); box-shadow: var(--shadow); margin-bottom: 16px;
    }
    .user-bar-avatar { width: 28px; height: 28px; border-radius: 50%; background: var(--c-lavender); }
    .user-bar-name { font-weight: 600; font-size: 0.88rem; }
    .user-bar-check { font-size: 0.8rem; color: var(--c-success); display: flex; align-items: center; gap: 4px; }
    .user-bar-logout { margin-left: auto; font-size: 0.78rem; color: var(--c-muted); cursor: pointer; text-decoration: underline; }

    /* Main grid */
    .main-grid {
      display: grid; grid-template-columns: 260px 1fr;
      gap: 16px; align-items: start;
    }
    .main-grid.full-width { grid-template-columns: 1fr; }
    .main-grid.full-width .step-login { display: none; }

    /* Steps */
    .step {
      background: var(--c-card); border-radius: var(--radius);
      padding: 24px; box-shadow: var(--shadow);
    }
    .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 14px; }
    .step-num {
      width: 32px; height: 32px; border-radius: 50%;
      background: linear-gradient(135deg, var(--c-rose), var(--c-lavender));
      color: #fff; display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 0.85rem; flex-shrink: 0;
    }
    .step-title { font-size: 1.05rem; font-weight: 700; }

    /* Step 1: Login */
    .step-login { text-align: center; }
    .step-login .login-desc { font-size: 0.85rem; color: #6B5B5B; margin-bottom: 14px; line-height: 1.5; }
    .step-login .login-note { font-size: 0.75rem; color: var(--c-muted); margin-top: 10px; }

    /* Buttons */
    .btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 8px;
      padding: 10px 24px; border: none; border-radius: var(--radius-sm);
      font-family: inherit; font-size: 0.9rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s; width: 100%;
    }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: var(--c-rose); color: #fff; }
    .btn-primary:hover:not(:disabled) { background: #c89494; box-shadow: var(--shadow); }
    .btn-spotify { background: var(--c-success); color: #fff; }
    .btn-spotify:hover:not(:disabled) { background: #1aa34a; box-shadow: 0 4px 16px rgba(29,185,84,0.3); }
    .btn-small { padding: 8px 16px; width: auto; font-size: 0.85rem; white-space: nowrap; }

    /* YT Music section */
    .ytm-section { margin-bottom: 14px; }
    .ytm-url-row { display: flex; gap: 8px; }
    .ytm-url-row input { flex: 1; }
    .ytm-status { font-size: 0.82rem; padding: 8px 12px; border-radius: 10px; margin-top: 8px; line-height: 1.4; }
    .ytm-status.loading { background: #F5F0FF; color: #7B6BA0; }
    .ytm-status.success { background: rgba(29,185,84,0.08); color: #1aa34a; }
    .ytm-status.error { background: rgba(192,112,112,0.08); color: var(--c-error); }

    .divider-or { text-align: center; margin: 14px 0; position: relative; }
    .divider-or span { background: var(--c-card); padding: 0 12px; font-size: 0.78rem; color: var(--c-muted); position: relative; z-index: 1; }
    .divider-or::before { content: ''; position: absolute; left: 0; right: 0; top: 50%; height: 1px; background: var(--c-border); }

    /* Channel results */
    .channel-info {
      display: flex; align-items: center; gap: 10px;
      padding: 10px; background: var(--c-bg); border-radius: var(--radius-sm); margin: 10px 0;
    }
    .channel-avatar { width: 36px; height: 36px; border-radius: 50%; }
    .channel-name { font-weight: 600; font-size: 0.9rem; }
    .channel-sub { font-size: 0.75rem; color: var(--c-muted); }
    .channel-grid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px; margin: 10px 0;
    }
    .channel-card {
      border-radius: var(--radius-sm); overflow: hidden;
      background: var(--c-bg); cursor: pointer; transition: all 0.2s;
    }
    .channel-card:hover { transform: translateY(-2px); box-shadow: var(--shadow); }
    .channel-card-thumb {
      width: 100%; aspect-ratio: 1; object-fit: cover; background: var(--c-border);
      display: block;
    }
    .channel-card-body { padding: 6px 8px 8px; }
    .channel-card-title {
      font-size: 0.78rem; font-weight: 500; line-height: 1.3;
      display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
    }
    .channel-card-count { font-size: 0.7rem; color: var(--c-muted); margin-top: 2px; }

    /* Inputs */
    input[type="text"], input[type="url"] {
      width: 100%; border: 2px solid var(--c-border); border-radius: var(--radius-sm);
      padding: 10px 14px; font-family: inherit; font-size: 0.9rem;
      background: var(--c-bg); color: var(--c-ink); transition: border-color 0.2s;
    }
    input:focus { outline: none; border-color: var(--c-lavender); }
    input::placeholder { color: var(--c-muted); }
    select {
      width: 100%; border: 2px solid var(--c-border); border-radius: var(--radius-sm);
      padding: 10px 14px; font-family: inherit; font-size: 0.9rem;
      background: var(--c-bg); color: var(--c-ink); cursor: pointer;
      appearance: none; -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23A09090' stroke-width='2'%3E%3Cpath d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
      background-repeat: no-repeat; background-position: right 14px center;
    }
    select:focus { outline: none; border-color: var(--c-lavender); }
    textarea {
      width: 100%; min-height: 120px;
      border: 2px solid var(--c-border); border-radius: var(--radius-sm);
      padding: 10px 14px; font-family: inherit; font-size: 0.85rem;
      line-height: 1.5; resize: vertical; transition: border-color 0.2s;
      background: var(--c-bg); color: var(--c-ink);
    }
    textarea:focus { outline: none; border-color: var(--c-lavender); }
    textarea::placeholder { color: var(--c-muted); }
    .input-row { display: flex; gap: 8px; margin-bottom: 12px; align-items: center; }
    .input-row label { font-size: 0.85rem; color: #6B5B5B; min-width: 65px; font-weight: 500; }
    .hint { font-size: 0.75rem; color: var(--c-muted); margin-top: 6px; line-height: 1.4; }

    /* Cover */
    .cover-section { margin-bottom: 14px; }
    .cover-row { display: flex; align-items: center; gap: 12px; }
    .cover-preview {
      width: 60px; height: 60px; border-radius: 10px; background: #F5F0EE;
      overflow: hidden; display: flex; align-items: center; justify-content: center;
      font-size: 0.6rem; color: var(--c-muted); flex-shrink: 0; cursor: pointer;
    }
    .cover-preview img { width: 100%; height: 100%; object-fit: cover; }
    .cover-preview-text { text-align: center; line-height: 1.3; }
    .cover-info { flex: 1; }
    .cover-info p { font-size: 0.75rem; color: var(--c-muted); line-height: 1.3; }
    .cover-remove { font-size: 0.75rem; color: var(--c-error); cursor: pointer; text-decoration: underline; margin-top: 2px; display: inline-block; }
    #coverFileInput { display: none; }

    /* Results */
    .step-results { margin-top: 16px; }
    .results { margin-top: 12px; }
    .result-item {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 0; border-bottom: 1px solid var(--c-border); font-size: 0.85rem;
    }
    .result-item:last-child { border-bottom: none; }
    .result-status {
      width: 22px; height: 22px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 0.7rem; flex-shrink: 0;
    }
    .result-status.found { background: rgba(29,185,84,0.1); color: var(--c-success); }
    .result-status.not-found { background: rgba(192,112,112,0.08); color: var(--c-error); }
    .result-info { flex: 1; min-width: 0; }
    .result-match { font-weight: 500; }
    .result-original { color: var(--c-muted); font-size: 0.75rem; }
    .result-link { color: var(--c-rose); text-decoration: none; font-size: 0.78rem; flex-shrink: 0; }

    /* Preview button (inline play/pause per track) */
    .preview-btn {
      width: 32px; height: 32px; border-radius: 50%; border: none;
      background: var(--c-rose); color: #fff; font-size: 12px;
      cursor: pointer; flex-shrink: 0; display: flex; align-items: center; justify-content: center;
      transition: background 0.2s, transform 0.15s;
    }
    .preview-btn:hover { background: var(--c-lavender); transform: scale(1.1); }
    .preview-btn.playing { background: var(--c-lavender); }

    /* Mini player (fixed bottom bar for audio preview) */
    .mini-player {
      position: fixed; bottom: 0; left: 0; right: 0; z-index: 999;
      background: rgba(255,255,255,0.96); backdrop-filter: blur(12px);
      border-top: 1px solid rgba(212,165,165,0.2);
      padding: 8px 16px; display: none; align-items: center; gap: 10px;
      box-shadow: 0 -2px 12px rgba(0,0,0,0.06);
    }
    .mini-player.active { display: flex; }
    .mini-player-info { flex: 1; min-width: 0; }
    .mini-player-title { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .mini-player-artist { font-size: 11px; color: var(--c-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .mini-player-btn {
      width: 36px; height: 36px; border-radius: 50%; border: none;
      background: var(--c-rose); color: #fff; font-size: 14px;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      flex-shrink: 0;
    }
    .mini-player-btn:hover { background: var(--c-lavender); }
    .mini-player-progress {
      flex: 1; height: 4px; background: #eee; border-radius: 2px;
      cursor: pointer; position: relative; min-width: 60px;
    }
    .mini-player-progress-fill {
      height: 100%; background: linear-gradient(90deg, var(--c-rose), var(--c-lavender));
      border-radius: 2px; width: 0%; transition: width 0.1s linear;
    }
    .mini-player-time { font-size: 11px; color: var(--c-muted); flex-shrink: 0; min-width: 32px; text-align: right; }
    .mini-player-close {
      background: none; border: none; color: var(--c-muted); cursor: pointer;
      font-size: 18px; padding: 0 4px; flex-shrink: 0;
    }
    .mini-player-close:hover { color: var(--c-ink); }

    .progress-bar { width: 100%; height: 5px; background: #F5F0EE; border-radius: 3px; overflow: hidden; margin: 10px 0; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, var(--c-rose), var(--c-lavender)); border-radius: 3px; transition: width 0.3s; width: 0%; }
    .progress-text { font-size: 0.78rem; color: var(--c-muted); text-align: center; }

    .summary { display: flex; gap: 10px; margin: 12px 0; }
    .summary-item { flex: 1; text-align: center; padding: 10px; border-radius: var(--radius-sm); background: var(--c-bg); }
    .summary-num { font-size: 1.3rem; font-weight: 700; }
    .summary-label { font-size: 0.72rem; color: var(--c-muted); margin-top: 1px; }
    .summary-item.found .summary-num { color: var(--c-success); }
    .summary-item.not-found .summary-num { color: var(--c-error); }
    .summary-item.total .summary-num { color: var(--c-lavender); }

    .status-msg { text-align: center; padding: 14px; border-radius: var(--radius-sm); margin: 10px 0; font-size: 0.88rem; }
    .status-msg.success { background: rgba(29,185,84,0.06); color: #1aa34a; }
    .status-msg.error { background: rgba(192,112,112,0.06); color: var(--c-error); }

    /* Toast */
    .toast {
      position: fixed; bottom: 24px; left: 50%;
      transform: translateX(-50%) translateY(80px);
      padding: 10px 22px; border-radius: var(--radius-sm);
      font-size: 0.88rem; font-weight: 500; color: #fff;
      background: var(--c-ink); box-shadow: var(--shadow);
      opacity: 0; transition: all 0.3s; z-index: 1000; pointer-events: none;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.success { background: var(--c-success); }
    .toast.error { background: var(--c-error); }

    /* Inline style replacements */
    .step-results { margin-top: 16px; }
    .select-all-row {
      display: flex; align-items: center; gap: 8px;
      margin: 8px 0 4px; font-size: 13px; color: var(--c-muted);
    }
    .select-all-label { display: inline-flex; align-items: center; gap: 5px; cursor: pointer; }
    .track-checkbox { accent-color: var(--c-rose); width: 16px; height: 16px; flex-shrink: 0; cursor: pointer; }
    .selected-count { margin-left: auto; }
    .create-section { margin-top: 16px; }
    .continue-section { margin-top: 14px; text-align: center; }
    .continue-section .btn { min-width: 160px; }
    .input-row-target { margin-top: 14px; }

    /* Footer */
    .footer {
      text-align: center; margin-top: 32px; padding: 20px 16px;
      border-top: 1px solid var(--c-border); font-size: 0.78rem; color: var(--c-muted); line-height: 1.6;
    }
    .footer a { color: var(--c-rose); font-weight: 500; }
    .footer .footer-brand { font-weight: 700; color: var(--c-ink); opacity: 0.5; }

    /* Dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --c-ink: #F0E8E4;
        --c-bg: #1E1A18;
        --c-card: #2A2422;
        --c-border: rgba(212,165,165,0.12);
        --c-muted: #8A7A74;
        --c-error: #D08080;
        --shadow: 0 4px 24px rgba(0,0,0,0.3);
      }
      body { -webkit-font-smoothing: antialiased; }
      input[type="text"], input[type="url"], textarea, select {
        background: #332D2A; color: var(--c-ink); border-color: rgba(212,165,165,0.15);
      }
      input::placeholder, textarea::placeholder { color: #6A5E58; }
      .hero-icon-box.ytm { background: rgba(255,0,0,0.1); }
      .hero-icon-box.sp { background: rgba(29,185,84,0.1); }
      .hero-sub { color: #B0A09A; }
      .badge { background: rgba(184,169,201,0.15); color: #A090B0; }
      .step-login .login-desc, .step-login .login-note { color: #B0A09A; }
      .input-row label { color: #B0A09A; }
      .mini-player { background: rgba(42,36,34,0.96); border-top-color: rgba(212,165,165,0.1); }
      .progress-bar { background: #332D2A; }
      .summary-item { background: #332D2A; }
      .channel-card { background: #332D2A; }
      .channel-info { background: #332D2A; }
      .user-bar { background: var(--c-card); }
      .status-msg.success { background: rgba(29,185,84,0.12); }
      .status-msg.error { background: rgba(208,128,128,0.12); }
      .ytm-status.loading { background: rgba(120,100,160,0.15); }
      .ytm-status.success { background: rgba(29,185,84,0.12); }
      .ytm-status.error { background: rgba(208,128,128,0.12); }
      .toast { background: #3A3230; }
      .footer { border-top-color: rgba(212,165,165,0.08); }
      .footer .footer-brand { color: var(--c-ink); }
      .cover-preview { background: #332D2A; }
      .divider-or span { background: var(--c-card); }
      .divider-or::before { background: rgba(212,165,165,0.1); }
      select {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%238A7A74' stroke-width='2'%3E%3Cpath d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
      }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .main-grid { grid-template-columns: 1fr; }
      .hero h1 { font-size: 1.5rem; }
      .hero { padding: 28px 16px 10px; }
      .container { padding: 0 12px 32px; }
      .step { padding: 18px 14px; border-radius: 18px; }
      .step-title { font-size: 0.98rem; }
      .ytm-url-row { flex-direction: column; }
      .ytm-url-row .btn { width: 100%; justify-content: center; }
      .channel-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
    }
  </style>
</head>
<body>
  <hello-ruru-header title="Spotify Goods — 歌曲整理小幫手"></hello-ruru-header>

  <header class="hero">
    <div class="hero-icons">
      <div class="hero-icon-box ytm">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
          <circle cx="12" cy="12" r="10" stroke="#FF0000" stroke-width="1.5" fill="none"/>
          <polygon points="10,8 16,12 10,16" fill="#FF0000"/>
        </svg>
      </div>
      <svg class="hero-arrow" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M5 12h14M13 6l6 6-6 6"/></svg>
      <div class="hero-icon-box sp">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="#1DB954"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/></svg>
      </div>
    </div>
    <h1 style="cursor:pointer;" onclick="resetToHome()" title="回到首頁">Spotify Goods</h1>
    <p class="hero-sub">從 YouTube Music 整理歌曲到 Spotify</p>
    <div class="hero-badges">
      <span class="badge">免費使用</span>
      <span class="badge">支援頻道匯入</span>
      <span class="badge">瀏覽器處理不上傳</span>
    </div>
  </header>

  <main class="container">

    <div style="display:flex; justify-content:center; gap:24px; flex-wrap:wrap; font-size:0.78rem; color:var(--c-muted); margin-bottom:16px; line-height:1.5;">
      <span><b style="color:var(--c-rose);">1.</b> 貼上 YouTube 網址</span>
      <span><b style="color:var(--c-lavender);">2.</b> 連接 Spotify 帳號</span>
      <span><b style="color:var(--c-success);">3.</b> 一鍵建立歌單</span>
    </div>

    <!-- User bar: shown after login, replaces Step 1 -->
    <div class="user-bar hidden" id="userBar">
      <img class="user-bar-avatar" id="userBarAvatar" src="" alt="">
      <span class="user-bar-name" id="userBarName"></span>
      <span class="user-bar-check">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M20 6L9 17l-5-5"/></svg>
        已連接
      </span>
      <span class="user-bar-logout" onclick="logoutSpotify()">登出</span>
    </div>

    <!-- Main grid: Step 1 (login) + Step 2 (import) -->
    <div class="main-grid" id="mainGrid">

      <!-- Step 1: Login Spotify -->
      <div class="step step-login" id="step1">
        <div class="step-header">
          <div class="step-num">1</div>
          <div class="step-title">連接 Spotify</div>
        </div>
        <p class="login-desc">登入你的 Spotify 帳號，歌單會建在你的帳號裡。</p>
        <button class="btn btn-spotify" onclick="loginSpotify()">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/></svg>
          連接 Spotify
        </button>
        <p class="login-note">免費帳號即可使用</p>
      </div>

      <!-- Step 2: Import Songs -->
      <div class="step step-import" id="step2">
        <div class="step-header">
          <div class="step-num">2</div>
          <div class="step-title">匯入歌曲</div>
        </div>

        <!-- YT Music URL -->
        <div class="ytm-section">
          <p style="font-size:0.85rem; color:#6B5B5B; margin-bottom:8px;">貼上 YouTube / YT Music 的播放清單、頻道或影片網址</p>
          <div class="ytm-url-row">
            <input type="url" id="ytmUrl" placeholder="播放清單、頻道、影片網址都可以" onkeydown="if(event.key==='Enter')fetchYTMusic()">
            <button class="btn btn-primary btn-small" id="btnFetchYTM" onclick="fetchYTMusic()">抓取</button>
          </div>
          <div id="ytmStatus" class="ytm-status hidden"></div>
        </div>

        <!-- Channel results (shown when channel URL detected) -->
        <div id="channelResults" class="hidden">
          <div class="channel-info" id="channelInfo"></div>
          <div class="channel-grid" id="channelGrid"></div>
        </div>

        <div class="divider-or"><span>或手動貼上</span></div>

        <textarea id="songInput" placeholder="每行一首，格式不拘：&#10;伍佰 - 突然的自我&#10;伍佰 - 挪威的森林&#10;有歌手名更準確"></textarea>
        <div class="hint">支援格式：歌手 - 歌名 / 歌手, 歌名 / 只有歌名都行</div>

        <div class="input-row input-row-target">
          <label>目標歌單</label>
          <select id="playlistTarget" onchange="togglePlaylistTarget()">
            <option value="new">建立新歌單</option>
          </select>
        </div>
        <div class="input-row" id="playlistNameRow">
          <label>歌單名稱</label>
          <div style="position:relative; flex:1;">
            <input type="text" id="playlistName" placeholder="例如：My Playlist" style="padding-right:28px;">
            <span id="clearPlaylistName" class="hidden" onclick="document.getElementById('playlistName').value=''; this.classList.add('hidden');" style="position:absolute; right:8px; top:50%; transform:translateY(-50%); cursor:pointer; color:var(--c-muted); font-size:1.1rem; line-height:1;" title="清空">&#10005;</span>
          </div>
        </div>

        <!-- Cover -->
        <div class="cover-section">
          <div class="cover-row">
            <div class="cover-preview" id="coverPreview" onclick="document.getElementById('coverFileInput').click()">
              <div class="cover-preview-text" id="coverPreviewText">上傳<br>封面</div>
              <img id="coverImg" class="hidden" src="" alt="">
            </div>
            <div class="cover-info">
              <p>選填，正方形 JPEG/PNG，最大 256KB</p>
              <span class="cover-remove hidden" id="coverRemove" onclick="removeCover()">移除封面</span>
            </div>
          </div>
          <input type="file" id="coverFileInput" accept="image/jpeg,image/png" onchange="handleCoverUpload(event)">
        </div>

        <button class="btn btn-primary" id="btnSearch" onclick="startSearch()">
          <span id="btnSearchText">連接 Spotify 並搜尋</span>
        </button>
      </div>

    </div>

    <!-- Step 3: Results + Create -->
    <div class="step step-results hidden" id="step3">
      <div class="step-header">
        <div class="step-num">3</div>
        <div class="step-title">比對結果</div>
      </div>
      <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
      <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
        <div class="progress-text" id="progressText">搜尋中...</div>
        <button class="btn hidden" id="btnCancelSearch" onclick="cancelSearch()" style="font-size:0.75rem; padding:3px 10px; min-width:auto; background:var(--c-card); color:var(--c-muted); border:1px solid var(--c-border);">取消</button>
      </div>
      <div class="summary hidden" id="summary">
        <div class="summary-item total"><div class="summary-num" id="totalCount">0</div><div class="summary-label">總共</div></div>
        <div class="summary-item found"><div class="summary-num" id="foundCount">0</div><div class="summary-label">找到</div></div>
        <div class="summary-item not-found"><div class="summary-num" id="notFoundCount">0</div><div class="summary-label">沒找到</div></div>
      </div>
      <div class="hint hidden" id="resultHint" style="margin:8px 0 4px; text-align:center;">可取消勾選不需要的歌曲，或回上方修改歌名後重新搜尋</div>
      <div class="hidden select-all-row" id="selectAllRow">
        <label class="select-all-label">
          <input type="checkbox" class="track-checkbox" id="selectAllBox" checked onchange="toggleSelectAll(this.checked)">
          全選
        </label>
        <span class="selected-count" id="selectedCount"></span>
      </div>
      <div class="results" id="resultsList"></div>
      <div class="hidden create-section" id="createSection">
        <button class="btn btn-spotify" id="btnCreate" onclick="createPlaylist()">建立歌單</button>
      </div>
      <div class="hidden" id="createStatus"></div>
      <div class="hidden continue-section" id="continueSection">
        <button class="btn btn-primary" onclick="resetToHome()">繼續新增</button>
      </div>
    </div>

    <details class="faq" style="margin: 24px 0 16px; font-size: 0.85rem; line-height: 1.7;">
      <summary style="cursor:pointer; font-weight:700; color:var(--c-ink); opacity:0.7;">常見問題</summary>
      <ul style="margin:12px 0 0; padding:0; list-style:none; display:flex; flex-direction:column; gap:14px; color:var(--c-muted);">
        <li><b style="color:var(--c-ink); opacity:0.85;">Q. 這是免費的嗎？</b><br>完全免費，不用註冊，也沒有廣告。</li>
        <li><b style="color:var(--c-ink); opacity:0.85;">Q. 我的資料安全嗎？</b><br>所有操作都在你的瀏覽器完成，登入資訊不會上傳到任何伺服器。</li>
        <li><b style="color:var(--c-ink); opacity:0.85;">Q. 支援哪些網址？</b><br>YouTube 影片、YouTube Music 歌單、頻道頁面都可以，也能直接手動輸入歌名。</li>
        <li><b style="color:var(--c-ink); opacity:0.85;">Q. 可以加進現有的 Spotify 歌單嗎？</b><br>可以，搜尋完成後選擇「加進現有歌單」，從你的歌單清單中挑選即可。</li>
        <li><b style="color:var(--c-ink); opacity:0.85;">Q. 為什麼有些歌找不到？</b><br>可能是 Spotify 沒有上架，或歌名與 Spotify 上的版本不同。你可以手動修改歌名再搜尋。</li>
        <li><b style="color:var(--c-ink); opacity:0.85;">Q. YouTube「播放電台」能用嗎？</b><br>電台是 YouTube 隨機推薦的，每個人不同，無法透過網址抓取。建議改貼一般歌單連結。</li>
      </ul>
    </details>

    <footer class="footer">
      <span class="footer-brand">HelloRuru</span> · <a href="https://tools.helloruru.com">更多工具</a> · <a href="https://ohruru.com">社群代操</a>
      <br><small style="opacity:0.55;">&#169; <span id="copyrightYear"></span> HelloRuru · 本工具使用 Spotify Web API，與 Spotify AB 及 YouTube / Google LLC 無隸屬關係。所有商標屬各自所有者。本工具不下載、不儲存任何音訊內容，僅讀取公開影片資訊以協助搜尋。登入資訊僅存於你的瀏覽器，不會上傳至任何伺服器。</small>
    </footer>
  </main>

  <div class="mini-player" id="miniPlayer">
    <button class="mini-player-btn" id="miniPlayBtn" onclick="toggleMiniPlayer()">&#9654;</button>
    <div class="mini-player-info">
      <div class="mini-player-title" id="miniTitle"></div>
      <div class="mini-player-artist" id="miniArtist"></div>
    </div>
    <div class="mini-player-progress" id="miniProgressBar" onclick="seekMiniPlayer(event)">
      <div class="mini-player-progress-fill" id="miniProgressFill"></div>
    </div>
    <div class="mini-player-time" id="miniTime">0:00</div>
    <button class="mini-player-close" onclick="closeMiniPlayer()" title="關閉">&#10005;</button>
  </div>

  <script>
    // ===== Config =====
    const SPOTIFY_CLIENT_ID = '6311e9e594cd4b968047a6b60eed5b52';
    const REDIRECT_URI = 'https://tools.helloruru.com/spotify-goods/';
    const SCOPES = 'playlist-modify-public playlist-modify-private playlist-read-private ugc-image-upload';

    const PIPED_INSTANCES = [
      'https://pipedapi.kavin.rocks',
      'https://pipedapi.adminforge.de',
      'https://api.piped.projectsegfault.com',
    ];

    // Fallback: self-hosted Worker (YT Music internal API, no Piped dependency)
    const WORKER_API = 'https://playlist-mover-api.vmpvmp1017.workers.dev';

    // ===== Token persistence =====
    const TOKEN_KEY = 'sg_token';
    function saveTokens(access, refresh, expiresIn) {
      localStorage.setItem(TOKEN_KEY, JSON.stringify({
        access_token: access,
        refresh_token: refresh,
        expires_at: Date.now() + expiresIn * 1000,
      }));
    }
    function loadTokens() {
      try { return JSON.parse(localStorage.getItem(TOKEN_KEY)); } catch { return null; }
    }
    function clearTokens() { localStorage.removeItem(TOKEN_KEY); }

    async function refreshAccessToken(refreshToken) {
      const res = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          client_id: SPOTIFY_CLIENT_ID,
          grant_type: 'refresh_token',
          refresh_token: refreshToken,
        }),
      });
      if (!res.ok) { clearTokens(); return false; }
      const data = await res.json();
      accessToken = data.access_token;
      saveTokens(data.access_token, data.refresh_token || refreshToken, data.expires_in || 3600);
      return true;
    }

    // ===== State =====
    let accessToken = null;
    let spotifyUser = null;
    let matchedTracks = [];
    let coverBase64 = null;
    let ytSongQueue = null; // Rich song data from YouTube auto-fetch

    // ===== Helpers =====
    // Parse a raw description/chapter line: extract artist + multi-language title segments
    // "Artist - スキップ / Skip / 스킵 / 跳躍" → { artist: "Artist", display: "スキップ", searchTitles: ["スキップ","Skip","스킵","跳躍"] }
    // "スキップ / Skip / 스킵 / 跳躍" → { artist: "", display: "スキップ", searchTitles: [...] }
    function parseRawSongLine(raw) {
      const slashParts = raw.split(/\s*\/\s*/).map(p => p.trim()).filter(p => p.length > 0);
      const first = slashParts[0] || raw.trim();

      // Try to extract artist from first segment (Artist - Title)
      let artist = '', title = first;
      const seps = [' - ', ' – ', ' — '];
      for (const sep of seps) {
        const idx = first.indexOf(sep);
        if (idx > 0) {
          artist = first.substring(0, idx).trim();
          title = first.substring(idx + sep.length).trim();
          break;
        }
      }

      // Build cascade search titles: original first, then english, then rest
      const searchTitles = [title];
      if (slashParts.length >= 3) {
        for (let i = 1; i < slashParts.length; i++) {
          const seg = slashParts[i].trim();
          if (seg && !searchTitles.includes(seg)) searchTitles.push(seg);
        }
        // Prioritize English segment as second choice
        const engIdx = searchTitles.findIndex((s, idx) => idx > 0 && /^[A-Za-z0-9]/.test(s) && /[a-zA-Z]{2,}/.test(s));
        if (engIdx > 1) {
          const [eng] = searchTitles.splice(engIdx, 1);
          searchTitles.splice(1, 0, eng);
        }
      }

      return { display: title, searchTitles, artist };
    }

    // Clean YouTube channel name → potential artist name
    function cleanChannelName(name) {
      return (name || '')
        .replace(/\s*-\s*Topic$/, '').replace(/ VEVO$/i, '')
        .replace(/\s*(Official|Music|Channel|公式)\s*/gi, ' ').trim();
    }

    // Clean YouTube title → sensible Spotify playlist name
    function cleanPlaylistName(title) {
      return (title || '')
        .replace(/【[^】]*】/g, '')           // 【作業用BGM】
        .replace(/\[[^\]]*\]/g, '')           // [Official]
        .replace(/\(Official.*?\)/gi, '')
        .replace(/[\u{1F600}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1FA00}-\u{1FAFF}]/gu, '') // emoji
        .replace(/\s+/g, ' ')
        .trim()
        .slice(0, 60);                        // Spotify max ~100, keep it short
    }

    function setPlaylistName(name) {
      const el = document.getElementById('playlistName');
      el.value = name;
      document.getElementById('clearPlaylistName').classList.toggle('hidden', !name);
    }

    // Tier 3: Enrich songs with artist names via YouTube (Piped) search
    async function enrichWithYTSearch(songs) {
      const needsArtist = songs.filter(s => !s.artist);
      if (!needsArtist.length) return;
      let done = 0;
      const BATCH = 4;
      for (let i = 0; i < needsArtist.length; i += BATCH) {
        const batch = needsArtist.slice(i, i + BATCH);
        await Promise.all(batch.map(async (song) => {
          const q = song.searchTitles[0];
          for (const inst of PIPED_INSTANCES) {
            try {
              const res = await fetch(`${inst}/search?q=${encodeURIComponent(q)}&filter=music_songs`, { signal: AbortSignal.timeout(5000) });
              if (!res.ok) continue;
              const data = await res.json();
              const items = (data.items || []).filter(it => it.type === 'stream');
              if (items.length > 0) {
                song.artist = cleanChannelName(items[0].uploaderName || '');
              }
              return;
            } catch { continue; }
          }
        }));
        done += batch.length;
        showYTMStatus('loading', `查找歌手中... ${needsArtist[Math.min(done, needsArtist.length) - 1]?.display || ''} (${done}/${needsArtist.length})`);
      }
    }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function esc(str) { const d = document.createElement('div'); d.textContent = str || ''; return d.innerHTML; }

    function showToast(msg, type) {
      let t = document.getElementById('toast');
      if (!t) { t = document.createElement('div'); t.id = 'toast'; t.className = 'toast'; document.body.appendChild(t); }
      t.textContent = msg;
      t.className = `toast ${type || ''} show`;
      setTimeout(() => t.classList.remove('show'), 3000);
    }

    // ===== PKCE =====
    function generateRandomString(len) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      const vals = crypto.getRandomValues(new Uint8Array(len));
      return Array.from(vals, v => chars[v % chars.length]).join('');
    }

    async function generateCodeChallenge(verifier) {
      const digest = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(verifier));
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    // ===== Init =====
    window.addEventListener('DOMContentLoaded', async () => {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');

      if (code) {
        // OAuth callback — exchange code for tokens
        const verifier = sessionStorage.getItem('pkce_verifier');
        if (verifier) {
          await exchangeCodeForToken(code, verifier);
          sessionStorage.removeItem('pkce_verifier');
          const saved = sessionStorage.getItem('sg_form');
          if (saved) {
            const form = JSON.parse(saved);
            if (form.name) setPlaylistName(form.name);
            if (form.songs) document.getElementById('songInput').value = form.songs;
            if (form.url) document.getElementById('ytmUrl').value = form.url;
            sessionStorage.removeItem('sg_form');
          }
        }
        window.history.replaceState({}, '', window.location.pathname);
      } else {
        // No OAuth callback — try restoring saved session
        const saved = loadTokens();
        if (saved) {
          if (Date.now() < saved.expires_at - 60000) {
            accessToken = saved.access_token;
            await fetchSpotifyUser();
          } else if (saved.refresh_token) {
            const ok = await refreshAccessToken(saved.refresh_token);
            if (ok) await fetchSpotifyUser();
          }
        }
      }

      const y = new Date().getFullYear();
      document.getElementById('copyrightYear').textContent = y > 2026 ? '2026\u2013' + y : '2026';
      // Show/hide clear button on playlist name input
      document.getElementById('playlistName').addEventListener('input', function() {
        document.getElementById('clearPlaylistName').classList.toggle('hidden', !this.value);
      });
      updateUI();
    });

    async function exchangeCodeForToken(code, verifier) {
      const res = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          client_id: SPOTIFY_CLIENT_ID, grant_type: 'authorization_code',
          code, redirect_uri: REDIRECT_URI, code_verifier: verifier,
        }),
      });
      if (!res.ok) return;
      const data = await res.json();
      accessToken = data.access_token;
      saveTokens(data.access_token, data.refresh_token, data.expires_in || 3600);
      await fetchSpotifyUser();
    }

    function updateUI() {
      const loggedIn = !!(accessToken && spotifyUser);
      const grid = document.getElementById('mainGrid');
      const userBar = document.getElementById('userBar');
      const btnSearch = document.getElementById('btnSearch');
      const btnSearchText = document.getElementById('btnSearchText');

      if (loggedIn) {
        grid.classList.add('full-width');
        userBar.classList.remove('hidden');
        btnSearchText.textContent = '搜尋 Spotify';
      } else {
        grid.classList.remove('full-width');
        userBar.classList.add('hidden');
        btnSearchText.textContent = '連接 Spotify 並搜尋';
      }
    }

    // ===== Spotify OAuth =====
    async function loginSpotify() {
      sessionStorage.setItem('sg_form', JSON.stringify({
        name: document.getElementById('playlistName')?.value || '',
        songs: document.getElementById('songInput')?.value || '',
        url: document.getElementById('ytmUrl')?.value || '',
      }));

      const verifier = generateRandomString(64);
      sessionStorage.setItem('pkce_verifier', verifier);
      const challenge = await generateCodeChallenge(verifier);

      const params = new URLSearchParams({
        client_id: SPOTIFY_CLIENT_ID, response_type: 'code',
        redirect_uri: REDIRECT_URI, scope: SCOPES,
        code_challenge_method: 'S256', code_challenge: challenge,
      });
      window.location.href = `https://accounts.spotify.com/authorize?${params}`;
    }

    async function fetchSpotifyUser() {
      const res = await fetch('https://api.spotify.com/v1/me', {
        headers: { Authorization: `Bearer ${accessToken}` },
      });
      if (res.status === 401) {
        const saved = loadTokens();
        if (saved?.refresh_token) {
          const ok = await refreshAccessToken(saved.refresh_token);
          if (ok) return fetchSpotifyUser();
        }
        clearTokens(); accessToken = null; return;
      }
      if (!res.ok) { clearTokens(); accessToken = null; return; }
      spotifyUser = await res.json();
      const name = spotifyUser.display_name || spotifyUser.id;
      document.getElementById('userBarName').textContent = name;
      const avatar = spotifyUser.images?.[0]?.url;
      if (avatar) document.getElementById('userBarAvatar').src = avatar;
      fetchUserPlaylists();
    }

    function logoutSpotify() {
      clearTokens();
      accessToken = null; spotifyUser = null;
      coverBase64 = null; matchedTracks = []; ytSongQueue = null;
      document.getElementById('step3').classList.add('hidden');
      const sel = document.getElementById('playlistTarget');
      while (sel.options.length > 1) sel.remove(1);
      sel.value = 'new';
      document.getElementById('playlistNameRow').classList.remove('hidden');
      updateUI();
    }

    // ===== Auto Thumbnail =====
    async function autoSetThumbnail(videoId) {
      if (coverBase64) return;
      try {
        const url = `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;
        const res = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);
        if (!res.ok) return;
        const blob = await res.blob();
        const dataUrl = await new Promise(r => {
          const rd = new FileReader();
          rd.onload = () => r(rd.result);
          rd.readAsDataURL(blob);
        });
        document.getElementById('coverImg').src = dataUrl;
        document.getElementById('coverImg').classList.remove('hidden');
        document.getElementById('coverPreviewText').classList.add('hidden');
        document.getElementById('coverRemove').classList.remove('hidden');
        const img = new Image();
        img.onload = () => {
          const c = document.createElement('canvas');
          c.width = 300; c.height = 300;
          const ctx = c.getContext('2d');
          const s = Math.min(img.width, img.height);
          ctx.drawImage(img, (img.width - s) / 2, (img.height - s) / 2, s, s, 0, 0, 300, 300);
          coverBase64 = c.toDataURL('image/jpeg', 0.9).split(',')[1];
        };
        img.src = dataUrl;
      } catch {}
    }

    // Auto-set thumbnail from a direct image URL (for playlists)
    async function autoSetThumbnailUrl(imageUrl) {
      if (coverBase64 || !imageUrl) return;
      try {
        const res = await fetch(imageUrl);
        if (!res.ok) return;
        const blob = await res.blob();
        const dataUrl = await new Promise(r => {
          const rd = new FileReader();
          rd.onload = () => r(rd.result);
          rd.readAsDataURL(blob);
        });
        document.getElementById('coverImg').src = dataUrl;
        document.getElementById('coverImg').classList.remove('hidden');
        document.getElementById('coverPreviewText').classList.add('hidden');
        document.getElementById('coverRemove').classList.remove('hidden');
        const img = new Image();
        img.onload = () => {
          const c = document.createElement('canvas');
          c.width = 300; c.height = 300;
          const ctx = c.getContext('2d');
          const s = Math.min(img.width, img.height);
          ctx.drawImage(img, (img.width - s) / 2, (img.height - s) / 2, s, s, 0, 0, 300, 300);
          coverBase64 = c.toDataURL('image/jpeg', 0.9).split(',')[1];
        };
        img.src = dataUrl;
      } catch {}
    }

    // ===== User Playlists =====
    async function fetchUserPlaylists() {
      if (!accessToken) return;
      try {
        const res = await spotifyFetch('https://api.spotify.com/v1/me/playlists?limit=50');
        if (!res.ok) {
          console.warn('fetchUserPlaylists failed:', res.status, res.statusText);
          return;
        }
        const data = await res.json();
        const sel = document.getElementById('playlistTarget');
        while (sel.options.length > 1) sel.remove(1);
        (data.items || []).forEach(pl => {
          const opt = document.createElement('option');
          opt.value = pl.id;
          opt.textContent = `${pl.name} (${pl.tracks.total} 首)`;
          sel.appendChild(opt);
        });
      } catch (err) {
        console.warn('fetchUserPlaylists error:', err);
      }
    }

    function togglePlaylistTarget() {
      const isNew = document.getElementById('playlistTarget').value === 'new';
      document.getElementById('playlistNameRow').classList.toggle('hidden', !isNew);
      document.getElementById('btnCreate').textContent = isNew ? '建立歌單' : '加入歌單';
    }

    // ===== Cover Upload =====
    function handleCoverUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      if (file.size > 256 * 1024) { showToast('圖片太大，最大 256KB', 'error'); e.target.value = ''; return; }

      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        document.getElementById('coverImg').src = dataUrl;
        document.getElementById('coverImg').classList.remove('hidden');
        document.getElementById('coverPreviewText').classList.add('hidden');
        document.getElementById('coverRemove').classList.remove('hidden');

        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const size = Math.min(img.width, img.height);
          canvas.width = 300; canvas.height = 300;
          const ctx = canvas.getContext('2d');
          const sx = (img.width - size) / 2, sy = (img.height - size) / 2;
          ctx.drawImage(img, sx, sy, size, size, 0, 0, 300, 300);
          coverBase64 = canvas.toDataURL('image/jpeg', 0.9).split(',')[1];
        };
        img.src = dataUrl;
      };
      reader.readAsDataURL(file);
    }

    function removeCover() {
      coverBase64 = null;
      document.getElementById('coverImg').classList.add('hidden');
      document.getElementById('coverImg').src = '';
      document.getElementById('coverPreviewText').classList.remove('hidden');
      document.getElementById('coverRemove').classList.add('hidden');
      document.getElementById('coverFileInput').value = '';
    }

    // ===== URL Parsers =====
    function extractPlaylistId(url) {
      try {
        const u = new URL(url);
        return u.searchParams.get('list');
      } catch {
        if (/^[A-Za-z0-9_-]+$/.test(url.trim())) return url.trim();
        return null;
      }
    }

    function extractChannelId(url) {
      try {
        const u = new URL(url);
        const match = u.pathname.match(/\/channel\/(UC[A-Za-z0-9_-]+)/);
        return match ? match[1] : null;
      } catch { return null; }
    }

    function extractVideoId(url) {
      try {
        const u = new URL(url);
        if (u.hostname === 'youtu.be') return u.pathname.slice(1).split('/')[0];
        if (u.searchParams.has('v')) return u.searchParams.get('v');
        return null;
      } catch { return null; }
    }

    // ===== YT Fetch (playlist / channel / video) =====
    async function fetchYTMusic() {
      const url = document.getElementById('ytmUrl').value.trim();
      if (!url) return;

      const btn = document.getElementById('btnFetchYTM');
      btn.disabled = true;
      document.getElementById('channelResults').classList.add('hidden');

      // 1. Channel URL
      const channelId = extractChannelId(url);
      if (channelId) { await fetchChannel(channelId); return; }

      const playlistId = extractPlaylistId(url);
      const videoId = extractVideoId(url);

      // 2. Regular playlist (skip radio RD prefix — try video first)
      if (playlistId && !playlistId.startsWith('RD')) {
        showYTMStatus('loading', '抓取播放清單中...');
        if (await fetchPlaylistSongs(playlistId)) { btn.disabled = false; return; }
      }

      // 3. Video description → parse songs
      if (videoId) {
        showYTMStatus('loading', '從影片描述抓取歌曲...');
        if (await fetchVideoSongs(videoId)) { btn.disabled = false; return; }
      }

      // 4. Radio playlist (RD) — try anyway as last resort
      if (playlistId && playlistId.startsWith('RD')) {
        showYTMStatus('loading', '嘗試抓取電台清單...');
        if (await fetchPlaylistSongs(playlistId)) { btn.disabled = false; return; }
        showYTMStatus('error', '這個是 YouTube 幫你隨機配的「播放電台」，每個人看到的歌都不一樣，所以我沒辦法幫你抓 &#x1F625; 你可以直接把想要的歌名打在上面，我來幫你找！');
        btn.disabled = false; return;
      }

      showYTMStatus('error', '無法辨識網址或抓取內容');
      btn.disabled = false;
    }

    // Fetch a playlist by ID, returns true if successful
    // Chain: Piped instances → self-hosted Worker (YT Music API)
    async function fetchPlaylistSongs(playlistId) {
      // 1) Try Piped instances
      for (const instance of PIPED_INSTANCES) {
        try {
          const ctrl = new AbortController();
          const timer = setTimeout(() => ctrl.abort(), 8000);
          const res = await fetch(`${instance}/playlists/${playlistId}`, { signal: ctrl.signal });
          clearTimeout(timer);
          if (!res.ok) continue;
          const data = await res.json();
          if (!data.relatedStreams?.length) continue;

          const songs = data.relatedStreams.map(s => {
            const parsed = parseVideoTitle(s.title, s.uploaderName);
            return `${parsed.artist} - ${parsed.title}`;
          });

          document.getElementById('songInput').value = songs.join('\n');
          if (data.name) setPlaylistName(cleanPlaylistName(data.name));
          if (data.thumbnailUrl) autoSetThumbnailUrl(data.thumbnailUrl);
          showYTMStatus('success', accessToken ? `成功抓到 ${songs.length} 首歌，搜尋 Spotify 中...` : `成功抓到 ${songs.length} 首歌！請先登入 Spotify 再搜尋。`);
          if (accessToken) startSearch();
          return true;
        } catch { continue; }
      }

      // 2) Fallback: self-hosted Worker (YT Music internal API)
      try {
        showYTMStatus('loading', '切換備用通道抓取中...');
        const res = await fetch(`${WORKER_API}/playlist?id=${encodeURIComponent(playlistId)}`);
        if (res.ok) {
          const data = await res.json();
          if (data.tracks?.length) {
            const songs = data.tracks.map(t =>
              t.artist ? `${t.artist} - ${t.title}` : t.title
            );
            document.getElementById('songInput').value = songs.join('\n');
            if (data.title) setPlaylistName(cleanPlaylistName(data.title));
            if (data.thumbnail) autoSetThumbnailUrl(data.thumbnail);
            showYTMStatus('success', accessToken ? `成功抓到 ${songs.length} 首歌，搜尋 Spotify 中...` : `成功抓到 ${songs.length} 首歌！請先登入 Spotify 再搜尋。`);
            if (accessToken) startSearch();
            return true;
          }
        }
      } catch {}

      return false;
    }

    // Fetch a single video, parse description for song list
    // Chain: Piped → Worker → CORS proxy → noembed
    async function fetchVideoSongs(videoId) {
      let data = null;

      // 1) Piped first — gives chapters + description (most complete)
      for (const instance of PIPED_INSTANCES) {
        try {
          const ctrl = new AbortController();
          const timer = setTimeout(() => ctrl.abort(), 8000);
          const res = await fetch(`${instance}/streams/${videoId}`, { signal: ctrl.signal });
          clearTimeout(timer);
          if (!res.ok) continue;
          const piped = await res.json();
          data = {
            title: piped.title || '',
            author: piped.uploaderName || piped.uploader || '',
            description: piped.description || '',
            chapters: piped.chapters || [],
          };
          break;
        } catch { continue; }
      }

      // 2) Self-hosted Worker fallback (server-side YouTube page parsing)
      if (!data) {
        try {
          const res = await fetch(`${WORKER_API}/video?id=${videoId}`);
          if (res.ok) {
            const j = await res.json();
            if (!j.error) {
              data = {
                title: j.title || '',
                author: j.author || '',
                description: j.description || '',
                chapters: (j.chapters || []).map(c => ({ title: c.title, start: Math.floor((c.startMs || 0) / 1000) })),
              };
            }
          }
        } catch {}
      }

      // 3) CORS proxy fallback
      if (!data) {
        const ytUrl = `https://www.youtube.com/watch?v=${videoId}`;
        const proxies = [
          u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
          u => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
        ];
        for (const proxyFn of proxies) {
          try {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(), 15000);
            const res = await fetch(proxyFn(ytUrl), { signal: ctrl.signal });
            clearTimeout(timer);
            if (!res.ok) continue;
            const html = await res.text();
            const parsed = parseYTPage(html);
            if (parsed) { data = parsed; break; }
          } catch { continue; }
        }
      }

      // 4) noembed (title + author only, no description)
      if (!data) {
        try {
          const res = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`);
          if (res.ok) {
            const oembed = await res.json();
            data = { title: oembed.title || '', author: oembed.author_name || '', description: '' };
          }
        } catch {}
      }

      if (!data) return false;

      // AI-generated music detection
      const aiHaystack = `${data.title || ''} ${data.author || ''} ${data.description || ''}`.toLowerCase();
      const aiKeywords = ['ai generated', 'ai music', 'ai 生成', 'ai生成', 'ai作曲', 'suno', 'udio', 'mubert', 'aiva', 'soundraw', 'boomy', 'loudly', 'beatoven', 'amper'];
      const isAI = aiKeywords.some(kw => aiHaystack.includes(kw));
      if (isAI) {
        showYTMStatus('loading', '偵測到這可能是 AI 生成的音樂，Spotify 上不一定找得到，先試試看！');
        await sleep(1500);
      }

      // Phase 1: try description for song list
      // 3-tier artist detection: ① description itself ② channel name ③ Piped search
      const descSongsRaw = parseSongsFromDescription(data.description || '');
      if (descSongsRaw.length >= 2) {
        // Tier 1: parse each line for "Artist - Title / Translation / ..."
        const richSongs = descSongsRaw.map(s => parseRawSongLine(s));
        document.getElementById('songInput').value = richSongs.map(s =>
          s.artist ? `${s.artist} - ${s.display}` : s.display
        ).join('\n');
        if (data.title) setPlaylistName(cleanPlaylistName(data.title));
        autoSetThumbnail(videoId);

        // Tier 2 skipped for multi-song: channel name is usually the curator, not the artist
        // Tier 3: Piped search for songs without artist
        const missing = richSongs.filter(s => !s.artist);
        if (missing.length > 0) {
          showYTMStatus('loading', `抓到 ${richSongs.length} 首歌，查找歌手中...（${missing.length} 首待確認）`);
          await enrichWithYTSearch(richSongs);
        }

        // Update textarea with final artist info
        document.getElementById('songInput').value = richSongs.map(s =>
          s.artist ? `${s.artist} - ${s.display}` : s.display
        ).join('\n');
        ytSongQueue = richSongs;
        showYTMStatus('success', accessToken ? `${richSongs.length} 首歌已就緒，搜尋 Spotify 中...` : `${richSongs.length} 首歌已就緒！請先登入 Spotify 再搜尋。`);
        if (accessToken) startSearch();
        return true;
      }

      // Phase 1.5: try chapters (same 3-tier artist detection)
      const chapters = data.chapters || [];
      if (chapters.length >= 2) {
        const richChapters = chapters
          .map(ch => parseRawSongLine((ch.title || '').trim()))
          .filter(s => s.display.length >= 2 && !/^(intro|outro|opening|ending|op|ed)$/i.test(s.display));
        if (richChapters.length >= 2) {
          document.getElementById('songInput').value = richChapters.map(s =>
            s.artist ? `${s.artist} - ${s.display}` : s.display
          ).join('\n');
          if (data.title) setPlaylistName(cleanPlaylistName(data.title));
          autoSetThumbnail(videoId);

          const missing = richChapters.filter(s => !s.artist);
          if (missing.length > 0) {
            showYTMStatus('loading', `抓到 ${richChapters.length} 首歌，查找歌手中...（${missing.length} 首待確認）`);
            await enrichWithYTSearch(richChapters);
          }

          document.getElementById('songInput').value = richChapters.map(s =>
            s.artist ? `${s.artist} - ${s.display}` : s.display
          ).join('\n');
          ytSongQueue = richChapters;
          showYTMStatus('success', accessToken ? `${richChapters.length} 首歌已就緒，搜尋 Spotify 中...` : `${richChapters.length} 首歌已就緒！請先登入 Spotify 再搜尋。`);
          if (accessToken) startSearch();
          return true;
        }
      }

      // Phase 2: fallback to video title itself (single song)
      const parsed = parseVideoTitle(data.title || '', data.author || '');
      if (parsed.title) {
        const line = parsed.artist ? `${parsed.artist} - ${parsed.title}` : parsed.title;
        document.getElementById('songInput').value = line;
        showYTMStatus('success', `辨識為單曲：${line}`);
        autoSetThumbnail(videoId);
        return true;
      }

      return false;
    }

    // Parse YouTube page HTML for video details (used by CORS proxy fallback)
    function parseYTPage(html) {
      try {
        const marker = 'var ytInitialPlayerResponse = ';
        const start = html.indexOf(marker);
        if (start !== -1) {
          const jsonStart = start + marker.length;
          const end1 = html.indexOf(';\nvar ', jsonStart);
          const end2 = html.indexOf(';</' + 'script>', jsonStart);
          const end = Math.min(
            end1 !== -1 ? end1 : Infinity,
            end2 !== -1 ? end2 : Infinity
          );
          if (end !== Infinity) {
            const d = JSON.parse(html.substring(jsonStart, end));
            const vd = d.videoDetails || {};
            return {
              title: vd.title || '',
              author: vd.author || '',
              description: vd.shortDescription || '',
            };
          }
        }
        // Regex fallback
        const t = html.match(/"title"\s*:\s*"((?:[^"\\]|\\.)*)"/);
        const a = html.match(/"author"\s*:\s*"((?:[^"\\]|\\.)*)"/);
        const desc = html.match(/"shortDescription"\s*:\s*"((?:[^"\\]|\\.)*)"/);
        if (t) {
          const unescape = s => { try { return JSON.parse(`"${s}"`); } catch { return s; } };
          return {
            title: unescape(t[1]),
            author: a ? unescape(a[1]) : '',
            description: desc ? unescape(desc[1]) : '',
          };
        }
      } catch {}
      return null;
    }

    // ===== Description Parser =====
    // Extracts song entries from YouTube video descriptions
    // Supports: timestamp lines, numbered lists, artist-title patterns
    function parseSongsFromDescription(desc) {
      if (!desc) return [];
      const lines = desc.split('\n');
      const hasSep = (s) => [' - ', ' – ', ' — ', ' | '].some(sep => s.includes(sep));

      // Phase 1: timestamp lines (e.g. "0:00 Artist - Song", "00:00 Song", "[1:23:45] Song")
      const tsRegex = /^[\[\(]?\d{0,2}:?\d{1,2}:\d{2}[\]\)]?\s*[-–—.]?\s*/;
      const tsLines = [];
      for (const line of lines) {
        const t = line.trim();
        if (tsRegex.test(t)) {
          const cleaned = t.replace(tsRegex, '').trim();
          if (cleaned.length >= 2 && !/^https?:\/\//.test(cleaned)) tsLines.push(cleaned);
        }
      }
      if (tsLines.length >= 2) return tsLines;

      // Phase 2: numbered list (e.g. "1. Artist - Song", "2) Song Name")
      const numLines = [];
      for (const line of lines) {
        const t = line.trim();
        const m = t.match(/^\d+[\.\)]\s+(.+)/);
        if (m) {
          const entry = m[1].trim();
          if (entry.length >= 2 && !/^https?:\/\//.test(entry)) numLines.push(entry);
        }
      }
      if (numLines.length >= 2) return numLines;

      // Phase 3: lines with artist-title separator (bulk consecutive lines)
      const sepLines = [];
      for (const line of lines) {
        const t = line.trim();
        if (t.length < 4) continue;
        if (/^https?:\/\//.test(t)) continue;
        if (/^[#➤►▶♫♪🔔👉↓@]/u.test(t)) continue;
        if (/^(subscribe|follow|like|share|turn on|copyright|license|provided)/i.test(t)) continue;
        if (hasSep(t)) sepLines.push(t);
      }
      if (sepLines.length >= 2) return sepLines;

      return [];
    }

    // ===== Artist Lookup (parallel batches) =====
    async function lookupArtists(entries) {
      const hasSep = (s) => [' - ', ' – ', ' — ', ' | '].some(sep => s.includes(sep));
      const result = new Array(entries.length);
      const needLookup = [];

      entries.forEach((entry, i) => {
        if (hasSep(entry)) { result[i] = entry; }
        else { needLookup.push(i); }
      });

      if (!needLookup.length) return result;

      const BATCH = 5;
      for (let b = 0; b < needLookup.length; b += BATCH) {
        const batch = needLookup.slice(b, b + BATCH);
        await Promise.all(batch.map(async i => {
          const artist = await findArtist(entries[i]);
          result[i] = artist ? `${artist} - ${entries[i]}` : entries[i];
        }));
        const done = Math.min(b + BATCH, needLookup.length);
        showYTMStatus('loading', `查詢歌手中... ${done} / ${needLookup.length}`);
      }
      return result;
    }

    async function findArtist(songTitle) {
      // Try Spotify first if logged in
      if (accessToken) {
        try {
          const params = new URLSearchParams({ q: songTitle, type: 'track', limit: '1', market: 'TW' });
          const res = await spotifyFetch(`https://api.spotify.com/v1/search?${params}`);
          if (res.ok) {
            const data = await res.json();
            const track = data.tracks?.items?.[0];
            if (track) return track.artists.map(a => a.name).join(', ');
          }
        } catch {}
      }

      // Fallback: iTunes Search API (free, no auth, CORS-friendly)
      try {
        const res = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(songTitle)}&entity=song&limit=1&country=TW`);
        if (res.ok) {
          const data = await res.json();
          if (data.results?.[0]?.artistName) return data.results[0].artistName;
        }
      } catch {}

      return null;
    }

    // ===== Channel Fetch (Piped API) =====
    async function fetchChannel(channelId) {
      const btn = document.getElementById('btnFetchYTM');
      btn.disabled = true;
      document.getElementById('channelResults').classList.add('hidden');
      showYTMStatus('loading', '抓取頻道中...');

      for (const instance of PIPED_INSTANCES) {
        try {
          const res = await fetch(`${instance}/channel/${channelId}`);
          if (!res.ok) continue;
          const data = await res.json();

          // Show channel info
          const infoEl = document.getElementById('channelInfo');
          const avatarUrl = data.avatarUrl || '';
          infoEl.innerHTML = `
            ${avatarUrl ? `<img class="channel-avatar" src="${esc(avatarUrl)}" alt="">` : ''}
            <div>
              <div class="channel-name">${esc(data.name || '未知頻道')}</div>
              <div class="channel-sub">${data.subscriberCount ? data.subscriberCount.toLocaleString() + ' 訂閱' : ''}</div>
            </div>`;

          // Try playlists tab
          const playlistsTab = data.tabs?.find(t => t.name === 'playlists');
          let playlists = [];

          if (playlistsTab) {
            try {
              const tabRes = await fetch(`${instance}/channels/tabs?data=${encodeURIComponent(playlistsTab.data)}`);
              if (tabRes.ok) {
                const tabData = await tabRes.json();
                playlists = (tabData.content || []).filter(item => item.type === 'playlist');
              }
            } catch {}
          }

          const gridEl = document.getElementById('channelGrid');
          gridEl.innerHTML = '';

          if (playlists.length > 0) {
            // Show playlist cards for user to pick
            playlists.forEach(pl => {
              const thumb = pl.thumbnail || '';
              const card = document.createElement('div');
              card.className = 'channel-card';
              const listId = pl.url?.split('list=')[1]?.split('&')[0] || '';
              card.onclick = () => fetchChannelPlaylist(listId, pl.name || '', instance);
              card.innerHTML = `
                <img class="channel-card-thumb" src="${esc(thumb)}" alt="" loading="lazy" onerror="this.style.background='var(--c-border)'">
                <div class="channel-card-body">
                  <div class="channel-card-title">${esc(pl.name || '未命名')}</div>
                  ${pl.videos >= 0 ? `<div class="channel-card-count">${pl.videos} 首</div>` : ''}
                </div>`;
              gridEl.appendChild(card);
            });

            showYTMStatus('success', `找到 ${playlists.length} 個播放清單，點擊選取`);
          } else if (data.relatedStreams?.length) {
            // No playlists tab — use uploaded videos directly
            const songs = data.relatedStreams.map(s => {
              const parsed = parseVideoTitle(s.title, s.uploaderName);
              return `${parsed.artist} - ${parsed.title}`;
            });
            document.getElementById('songInput').value = songs.join('\n');
            if (data.name) setPlaylistName(cleanPlaylistName(data.name));
            showYTMStatus('success', `從頻道抓到 ${songs.length} 首歌！`);
            btn.disabled = false;
            return;
          } else {
            showYTMStatus('error', '頻道沒有可用的內容');
            btn.disabled = false;
            return;
          }

          document.getElementById('channelResults').classList.remove('hidden');
          btn.disabled = false;
          return;
        } catch { continue; }
      }

      // Fallback: self-hosted Worker (YT Music internal API)
      try {
        showYTMStatus('loading', '切換備用通道抓取頻道...');
        const res = await fetch(`${WORKER_API}/channel?id=${encodeURIComponent(channelId)}`);
        if (res.ok) {
          const data = await res.json();
          const infoEl = document.getElementById('channelInfo');
          infoEl.innerHTML = `
            ${data.thumbnail ? `<img class="channel-avatar" src="${esc(data.thumbnail)}" alt="">` : ''}
            <div><div class="channel-name">${esc(data.channelName || '未知頻道')}</div></div>`;

          const gridEl = document.getElementById('channelGrid');
          gridEl.innerHTML = '';

          // Flatten all sections into playlist cards
          const allItems = (data.sections || []).flatMap(s => s.items || []);
          if (allItems.length > 0) {
            allItems.forEach(item => {
              const card = document.createElement('div');
              card.className = 'channel-card';
              card.onclick = () => fetchPlaylistFromWorker(item.playlistId, item.title);
              card.innerHTML = `
                <img class="channel-card-thumb" src="${esc(item.thumbnail || '')}" alt="" loading="lazy" onerror="this.style.background='var(--c-border)'">
                <div class="channel-card-body">
                  <div class="channel-card-title">${esc(item.title || '未命名')}</div>
                  <div class="channel-card-count">${esc(item.subtitle || '')}</div>
                </div>`;
              gridEl.appendChild(card);
            });
            document.getElementById('channelResults').classList.remove('hidden');
            showYTMStatus('success', `找到 ${allItems.length} 個播放清單，點擊選取`);
            btn.disabled = false;
            return;
          }
        }
      } catch {}

      showYTMStatus('error', '無法抓取頻道資料');
      btn.disabled = false;
    }

    // Fetch a single playlist via Worker (used by channel card clicks)
    async function fetchPlaylistFromWorker(playlistId, name) {
      if (!playlistId) return;
      showYTMStatus('loading', `抓取「${name}」中...`);
      try {
        const res = await fetch(`${WORKER_API}/playlist?id=${encodeURIComponent(playlistId)}`);
        if (!res.ok) { showYTMStatus('error', `無法抓取「${name}」`); return; }
        const data = await res.json();
        if (!data.tracks?.length) { showYTMStatus('error', `「${name}」沒有歌曲`); return; }

        const songs = data.tracks.map(t => t.artist ? `${t.artist} - ${t.title}` : t.title);
        const existing = document.getElementById('songInput').value.trim();
        document.getElementById('songInput').value = existing ? existing + '\n' + songs.join('\n') : songs.join('\n');
        if (!document.getElementById('playlistName').value && name) {
          setPlaylistName(cleanPlaylistName(name));
        }
        showYTMStatus('success', `已加入「${name}」${songs.length} 首歌`);
      } catch {
        showYTMStatus('error', `無法抓取「${name}」`);
      }
    }

    async function fetchChannelPlaylist(listId, name, instance) {
      if (!listId) return;

      showYTMStatus('loading', `抓取「${name}」中...`);

      const instances = instance ? [instance, ...PIPED_INSTANCES.filter(i => i !== instance)] : PIPED_INSTANCES;
      for (const inst of instances) {
        try {
          const res = await fetch(`${inst}/playlists/${listId}`);
          if (!res.ok) continue;
          const data = await res.json();
          if (!data.relatedStreams?.length) continue;

          const songs = data.relatedStreams.map(s => {
            const parsed = parseVideoTitle(s.title, s.uploaderName);
            return `${parsed.artist} - ${parsed.title}`;
          });

          // Append to existing songs
          const existing = document.getElementById('songInput').value.trim();
          if (existing) {
            document.getElementById('songInput').value = existing + '\n' + songs.join('\n');
          } else {
            document.getElementById('songInput').value = songs.join('\n');
          }

          if (!document.getElementById('playlistName').value && name) {
            setPlaylistName(cleanPlaylistName(name));
          }

          showYTMStatus('success', `已加入「${name}」${songs.length} 首歌`);
          return;
        } catch { continue; }
      }

      showYTMStatus('error', `無法抓取「${name}」`);
    }

    function parseVideoTitle(videoTitle, uploaderName) {
      let clean = videoTitle
        .replace(/\(Official\s*(Music\s*)?Video\)/gi, '')
        .replace(/\(Official\s*MV\)/gi, '')
        .replace(/\(MV\)/gi, '')
        .replace(/\(Lyric\s*Video\)/gi, '')
        .replace(/\(Audio\)/gi, '')
        .replace(/\(Visualizer\)/gi, '')
        .replace(/【[^】]*】/g, '')
        .replace(/\[[^\]]*\]/g, '')
        .replace(/\s+/g, ' ')
        .trim();

      const seps = [' - ', ' – ', ' — ', ' | '];
      for (const sep of seps) {
        const idx = clean.indexOf(sep);
        if (idx > 0) return { artist: clean.substring(0, idx).trim(), title: clean.substring(idx + sep.length).trim() };
      }

      const artist = uploaderName?.replace(/\s*-\s*Topic$/, '').replace(/ VEVO$/i, '').trim() || '';
      return { title: clean, artist };
    }

    function showYTMStatus(type, msg) {
      const el = document.getElementById('ytmStatus');
      el.classList.remove('hidden');
      el.className = `ytm-status ${type}`;
      el.textContent = msg;
    }

    // ===== Parse Songs =====
    function parseSongs(text) {
      return text.split('\n')
        .map(l => l.trim())
        .filter(l => l && !/^\d+\.\s*$/.test(l))
        .map(line => {
          line = line.replace(/^\d+[\.\)]\s*/, '').replace(/^[-•]\s*/, '').trim();
          const seps = [' - ', ' – ', ' — ', ' | ', ' / ', ', '];
          for (const sep of seps) {
            const idx = line.indexOf(sep);
            if (idx > 0) return { title: line.substring(idx + sep.length).trim(), artist: line.substring(0, idx).trim() };
          }
          return { title: line, artist: '' };
        });
    }

    // ===== Spotify API with Rate Limit + Token Refresh =====
    let _refreshingToken = false;
    async function spotifyFetch(url, options = {}) {
      const res = await fetch(url, {
        ...options,
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });
      if (res.status === 429) {
        const wait = parseInt(res.headers.get('Retry-After') || '3', 10);
        await sleep(wait * 1000);
        return spotifyFetch(url, options);
      }
      if (res.status === 401 && !_refreshingToken) {
        _refreshingToken = true;
        const saved = loadTokens();
        if (saved?.refresh_token) {
          const ok = await refreshAccessToken(saved.refresh_token);
          _refreshingToken = false;
          if (ok) return spotifyFetch(url, options);
        }
        _refreshingToken = false;
      }
      return res;
    }

    // Normalize string for comparison: lowercase, remove punctuation/extra spaces
    function normalize(s) {
      return (s || '').toLowerCase()
        .replace(/[''`]/g, "'")
        .replace(/[""]/g, '"')
        .replace(/[^\w\s\u3000-\u9fff\uac00-\ud7af'\-]/g, ' ')
        .replace(/\s+/g, ' ').trim();
    }

    // Strict match: a must contain b, or b must contain a (exact or substring)
    function strictMatch(a, b) {
      if (!a || !b) return false;
      a = normalize(a); b = normalize(b);
      return a === b || a.includes(b) || b.includes(a);
    }

    // Validate a Spotify result:
    // - Has artist → artist MUST match (gatekeeper), title trusts Spotify ranking
    // - No artist → title must match strictly
    function isGoodMatch(track, queryTitle, queryArtist) {
      const qArtist = normalize(queryArtist);
      const tArtists = track.artists.map(a => normalize(a.name));

      if (qArtist) {
        // Artist is the gatekeeper — must match strictly
        return tArtists.some(a => strictMatch(a, qArtist));
      }

      // No artist → title must match
      return strictMatch(normalize(track.name), normalize(queryTitle));
    }

    async function searchSpotify(titles, artist) {
      // titles: string or array of title variants to try (original language first)
      if (typeof titles === 'string') titles = [titles];

      for (const title of titles) {
        // Phase A: with artist (if available)
        if (artist) {
          const artistQueries = [`track:${title} artist:${artist}`, `${title} ${artist}`];
          for (const query of artistQueries) {
            const params = new URLSearchParams({ q: query, type: 'track', limit: '5', market: 'TW' });
            const res = await spotifyFetch(`https://api.spotify.com/v1/search?${params}`);
            if (!res.ok) return null;
            const data = await res.json();
            const tracks = data.tracks?.items;
            if (!tracks?.length) continue;
            for (const t of tracks) {
              if (isGoodMatch(t, title, artist)) {
                return { uri: t.uri, name: t.name, artist: t.artists.map(a => a.name).join(', '), url: t.external_urls.spotify, preview: t.preview_url || null };
              }
            }
          }
        }

        // Phase B: title only (fallback — artist might be wrong or absent)
        const params = new URLSearchParams({ q: title, type: 'track', limit: '5', market: 'TW' });
        const res = await spotifyFetch(`https://api.spotify.com/v1/search?${params}`);
        if (!res.ok) return null;
        const data = await res.json();
        const tracks = data.tracks?.items;
        if (tracks?.length) {
          for (const t of tracks) {
            if (isGoodMatch(t, title, '')) {
              return { uri: t.uri, name: t.name, artist: t.artists.map(a => a.name).join(', '), url: t.external_urls.spotify, preview: t.preview_url || null };
            }
          }
        }
      }

      return null;
    }

    // ===== Search Flow =====
    let searchAborted = false;

    function cancelSearch() {
      searchAborted = true;
      document.getElementById('btnCancelSearch').classList.add('hidden');
    }

    async function startSearch() {
      // Not logged in → redirect to Spotify login (will return here after)
      if (!accessToken) {
        loginSpotify();
        return;
      }

      // Use rich YT data if available, otherwise parse from textarea
      let songs;
      if (ytSongQueue) {
        songs = ytSongQueue;
        ytSongQueue = null;
      } else {
        const input = document.getElementById('songInput').value;
        const parsed = parseSongs(input);
        songs = parsed.map(s => ({
          display: s.artist ? `${s.artist} - ${s.title}` : s.title,
          searchTitles: [s.title],
          artist: s.artist,
        }));
      }
      if (!songs.length) { showToast('請先貼上歌名', 'error'); return; }

      searchAborted = false;
      document.getElementById('step3').classList.remove('hidden');
      document.getElementById('summary').classList.add('hidden');
      document.getElementById('resultHint').classList.add('hidden');
      document.getElementById('createSection').classList.add('hidden');
      document.getElementById('createStatus').classList.add('hidden');
      document.getElementById('selectAllRow').classList.add('hidden');
      document.getElementById('resultsList').innerHTML = '';
      matchedTracks = [];
      closeMiniPlayer();

      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
      const btnSearch = document.getElementById('btnSearch');
      const btnCancel = document.getElementById('btnCancelSearch');
      btnSearch.disabled = true;
      progressFill.style.width = '0%';
      if (songs.length >= 5) btnCancel.classList.remove('hidden');

      let found = 0, notFound = 0;

      for (let i = 0; i < songs.length; i++) {
        if (searchAborted) break;

        const song = songs[i];
        const pct = ((i + 1) / songs.length * 100).toFixed(0);
        progressFill.style.width = pct + '%';
        progressText.textContent = `搜尋中... ${i + 1} / ${songs.length}`;

        const result = await searchSpotify(song.searchTitles, song.artist);
        const queryLabel = song.artist ? `${song.display} (${song.artist})` : song.display;
        const item = {
          query: queryLabel,
          spotifyUri: result?.uri || null,
          spotifyName: result?.name || null,
          spotifyArtist: result?.artist || null,
          spotifyUrl: result?.url || null,
          preview: result?.preview || null,
        };
        matchedTracks.push(item);

        if (result) { found++; appendResult(item, true); }
        else { notFound++; appendResult(item, false); }

        if (i < songs.length - 1) await sleep(200);
      }

      btnCancel.classList.add('hidden');
      const searched = found + notFound;
      progressText.textContent = searchAborted ? `已取消（已搜 ${searched} / ${songs.length} 首）` : '搜尋完成';
      document.getElementById('summary').classList.remove('hidden');
      document.getElementById('resultHint').classList.remove('hidden');
      document.getElementById('totalCount').textContent = searched;
      document.getElementById('foundCount').textContent = found;
      document.getElementById('notFoundCount').textContent = notFound;
      btnSearch.disabled = false;
      document.getElementById('btnSearchText').textContent = '搜尋 Spotify';
      if (found > 0) {
        document.getElementById('createSection').classList.remove('hidden');
        document.getElementById('selectAllRow').classList.remove('hidden');
        document.getElementById('selectAllBox').checked = true;
        updateSelectedCount();
      }
    }

    let currentAudio = null;
    let currentPlayBtn = null;
    let miniAnimFrame = null;

    function appendResult(item, isFound) {
      const idx = matchedTracks.length - 1;
      const div = document.createElement('div');
      div.className = 'result-item';
      div.dataset.idx = idx;
      if (isFound) {
        const previewBtn = item.preview
          ? `<button class="preview-btn" data-url="${esc(item.preview)}" onclick="togglePreview(this)" title="試聽">&#9654;</button>`
          : '';
        div.innerHTML = `
          <input type="checkbox" class="track-check track-checkbox" data-idx="${idx}" checked onchange="updateSelectedCount()">
          ${previewBtn}
          <div class="result-info">
            <div class="result-match">${esc(item.spotifyName)} — ${esc(item.spotifyArtist)}</div>
            <div class="result-original">${esc(item.query)}</div>
          </div>
          <a class="result-link" href="${esc(item.spotifyUrl)}" target="_blank" rel="noopener">開啟</a>`;
      } else {
        div.innerHTML = `
          <div class="result-status not-found">&#10007;</div>
          <div class="result-info">
            <div class="result-match" style="color:var(--c-muted)">${esc(item.query)}</div>
            <div class="result-original">在 Spotify 找不到</div>
          </div>`;
      }
      document.getElementById('resultsList').appendChild(div);
    }

    function togglePreview(btn) {
      const url = btn.dataset.url;
      const resultItem = btn.closest('.result-item');
      const nameEl = resultItem?.querySelector('.result-match');
      const parts = (nameEl?.textContent || '').split(' — ');

      // If clicking same song, toggle pause/play
      if (currentPlayBtn === btn && currentAudio) {
        if (currentAudio.paused) {
          currentAudio.play();
          btn.innerHTML = '&#9646;&#9646;'; btn.classList.add('playing');
          document.getElementById('miniPlayBtn').innerHTML = '&#9646;&#9646;';
        } else {
          currentAudio.pause();
          btn.innerHTML = '&#9654;'; btn.classList.remove('playing');
          document.getElementById('miniPlayBtn').innerHTML = '&#9654;';
        }
        return;
      }

      // Stop current
      if (currentAudio) {
        currentAudio.pause();
        if (currentPlayBtn) { currentPlayBtn.innerHTML = '&#9654;'; currentPlayBtn.classList.remove('playing'); }
        if (miniAnimFrame) cancelAnimationFrame(miniAnimFrame);
      }

      // Play new
      const audio = new Audio(url);
      audio.volume = 0.5;
      audio.play();
      btn.innerHTML = '&#9646;&#9646;'; btn.classList.add('playing');
      currentAudio = audio;
      currentPlayBtn = btn;

      // Show mini player
      const mp = document.getElementById('miniPlayer');
      mp.classList.add('active');
      document.getElementById('miniTitle').textContent = parts[0] || '';
      document.getElementById('miniArtist').textContent = parts[1] || '';
      document.getElementById('miniPlayBtn').innerHTML = '&#9646;&#9646;';
      document.getElementById('miniProgressFill').style.width = '0%';
      document.getElementById('miniTime').textContent = '0:00';

      // Progress update loop
      function updateProgress() {
        if (!currentAudio) return;
        const pct = currentAudio.duration ? (currentAudio.currentTime / currentAudio.duration * 100) : 0;
        document.getElementById('miniProgressFill').style.width = pct + '%';
        const s = Math.floor(currentAudio.currentTime);
        document.getElementById('miniTime').textContent = `${Math.floor(s / 60)}:${String(s % 60).padStart(2, '0')}`;
        miniAnimFrame = requestAnimationFrame(updateProgress);
      }
      miniAnimFrame = requestAnimationFrame(updateProgress);

      audio.onended = () => {
        btn.innerHTML = '&#9654;'; btn.classList.remove('playing');
        document.getElementById('miniPlayBtn').innerHTML = '&#9654;';
        document.getElementById('miniProgressFill').style.width = '100%';
        if (miniAnimFrame) cancelAnimationFrame(miniAnimFrame);
        currentAudio = null; currentPlayBtn = null;
      };
    }

    function toggleMiniPlayer() {
      if (!currentAudio) return;
      if (currentAudio.paused) {
        currentAudio.play();
        document.getElementById('miniPlayBtn').innerHTML = '&#9646;&#9646;';
        if (currentPlayBtn) { currentPlayBtn.innerHTML = '&#9646;&#9646;'; currentPlayBtn.classList.add('playing'); }
      } else {
        currentAudio.pause();
        document.getElementById('miniPlayBtn').innerHTML = '&#9654;';
        if (currentPlayBtn) { currentPlayBtn.innerHTML = '&#9654;'; currentPlayBtn.classList.remove('playing'); }
      }
    }

    function seekMiniPlayer(e) {
      if (!currentAudio || !currentAudio.duration) return;
      const bar = document.getElementById('miniProgressBar');
      const rect = bar.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      currentAudio.currentTime = pct * currentAudio.duration;
    }

    function closeMiniPlayer() {
      if (currentAudio) { currentAudio.pause(); currentAudio = null; }
      if (currentPlayBtn) { currentPlayBtn.innerHTML = '&#9654;'; currentPlayBtn.classList.remove('playing'); currentPlayBtn = null; }
      if (miniAnimFrame) cancelAnimationFrame(miniAnimFrame);
      document.getElementById('miniPlayer').classList.remove('active');
    }

    function toggleSelectAll(checked) {
      document.querySelectorAll('.track-check').forEach(cb => { cb.checked = checked; });
      updateSelectedCount();
    }

    function updateSelectedCount() {
      const total = document.querySelectorAll('.track-check').length;
      const selected = document.querySelectorAll('.track-check:checked').length;
      document.getElementById('selectedCount').textContent = `${selected} / ${total} 首`;
      // Sync select-all checkbox
      const selectAll = document.getElementById('selectAllBox');
      if (selectAll) selectAll.checked = selected === total;
    }

    // ===== Create / Add to Playlist =====
    async function createPlaylist() {
      if (!accessToken || !spotifyUser) return;

      const btnCreate = document.getElementById('btnCreate');
      const statusDiv = document.getElementById('createStatus');
      btnCreate.disabled = true;
      statusDiv.classList.remove('hidden');
      statusDiv.className = 'status-msg';

      const target = document.getElementById('playlistTarget').value;
      // Only include checked tracks
      const checkedIdxs = new Set();
      document.querySelectorAll('.track-check:checked').forEach(cb => checkedIdxs.add(parseInt(cb.dataset.idx)));
      const uris = matchedTracks
        .filter((t, i) => t.spotifyUri && checkedIdxs.has(i))
        .map(t => t.spotifyUri);

      if (!uris.length) {
        statusDiv.className = 'status-msg error';
        statusDiv.textContent = '沒有可加入的歌曲';
        btnCreate.disabled = false;
        return;
      }

      try {
        let playlistId, playlistUrl, playlistName;

        if (target === 'new') {
          playlistName = document.getElementById('playlistName').value || 'My Playlist';
          statusDiv.textContent = '建立歌單中...';
          const createRes = await spotifyFetch('https://api.spotify.com/v1/me/playlists', {
            method: 'POST',
            body: JSON.stringify({ name: playlistName, description: '由 Spotify Goods (HelloRuru Tools) 建立', public: false }),
          });
          if (!createRes.ok) throw new Error('建立歌單失敗');
          const pl = await createRes.json();
          playlistId = pl.id;
          playlistUrl = pl.external_urls.spotify;
        } else {
          playlistId = target;
          const sel = document.getElementById('playlistTarget');
          playlistName = sel.options[sel.selectedIndex].textContent.replace(/ \(\d+ 首\)$/, '');
          playlistUrl = `https://open.spotify.com/playlist/${playlistId}`;
          statusDiv.textContent = '加入歌曲中...';
        }

        for (let i = 0; i < uris.length; i += 100) {
          const batch = uris.slice(i, i + 100);
          const addRes = await spotifyFetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
            method: 'POST',
            body: JSON.stringify({ uris: batch }),
          });
          if (!addRes.ok) throw new Error('加入歌曲失敗');
        }

        if (coverBase64) {
          statusDiv.textContent = '上傳封面中...';
          try {
            await spotifyFetch(`https://api.spotify.com/v1/playlists/${playlistId}/images`, {
              method: 'PUT',
              headers: { 'Content-Type': 'image/jpeg' },
              body: coverBase64,
            });
          } catch {
            showToast('封面上傳失敗，歌曲已加入', 'error');
          }
        }

        const verb = target === 'new' ? '建立成功' : '已加入';
        statusDiv.className = 'status-msg success';
        statusDiv.innerHTML = `歌單「${esc(playlistName)}」${verb}！共 ${uris.length} 首<br>
          <a href="${playlistUrl}" target="_blank" rel="noopener"
             style="color:#1DB954;font-weight:600;">在 Spotify 開啟歌單</a>`;
        showToast(`歌單${verb}！`, 'success');
        fetchUserPlaylists();
        document.getElementById('continueSection').classList.remove('hidden');
      } catch (err) {
        statusDiv.className = 'status-msg error';
        statusDiv.textContent = err.message;
        showToast('失敗：' + err.message, 'error');
      }

      btnCreate.disabled = false;
    }

    // ===== Reset to Home =====
    function resetToHome() {
      searchAborted = true;
      document.getElementById('btnCancelSearch').classList.add('hidden');
      document.getElementById('step3').classList.add('hidden');
      document.getElementById('continueSection').classList.add('hidden');
      document.getElementById('createSection').classList.add('hidden');
      document.getElementById('createStatus').classList.add('hidden');
      document.getElementById('selectAllRow').classList.add('hidden');
      document.getElementById('resultsList').innerHTML = '';
      document.getElementById('summary').classList.add('hidden');
      document.getElementById('resultHint').classList.add('hidden');
      document.getElementById('progressBar').style.display = 'none';
      document.getElementById('progressText').textContent = '';
      document.getElementById('songInput').value = '';
      document.getElementById('ytmUrl').value = '';
      document.getElementById('ytmStatus').classList.add('hidden');
      document.getElementById('channelResults').classList.add('hidden');
      setPlaylistName('');
      const coverImg = document.getElementById('coverImg');
      if (coverImg) { coverImg.src = ''; coverImg.classList.add('hidden'); }
      const coverText = document.getElementById('coverPreviewText');
      if (coverText) coverText.classList.remove('hidden');
      const coverRemove = document.getElementById('coverRemove');
      if (coverRemove) coverRemove.classList.add('hidden');
      coverBase64 = null;
      matchedTracks = [];
      ytSongQueue = null;
      closeMiniPlayer();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  </script>
</body>
</html>
